/*
Install the Firebase Node.js module with npm from the command line:

$ npm install firebase --save

To use the Firebase Node.js module in your application, require the Firebase module:

var firebase = require("firebase");

Then, initialize the Firebase SDK using the code snippet from above, which should look like this:

// Initialize Firebase
// TODO: Replace with your project's customized code snippet
var config = {
  apiKey: "<API_KEY>",
  authDomain: "<PROJECT_ID>.firebaseapp.com",
  databaseURL: "https://<DATABASE_NAME>.firebaseio.com",
  storageBucket: "<BUCKET>.appspot.com",
};
firebase.initializeApp(config);

Use Firebase services

A Firebase App can use multiple Firebase services. Each service can 
be accessed from the firebase namespace:

    firebase.auth() - Authentication
    firebase.storage() - Storage
    firebase.database() - Realtime Database

See the individual services for documentation on their use.
Run a Local Web Server for Development

If you are building a web app, you will find that some parts of the Firebase 
JavaScript SDK require that your web app be served from a server rather than 
from the local filesystem. You can use the Firebase CLI to run a local server like this:

$ npm install -g firebase-tools
$ firebase serve

Deploy your Web App Using Firebase Hosting

If you are building a web app and your web app is entirely static content, 
you can deploy it easily using Firebase Hosting.

Firebase Hosting is developer-focused static web hosting for modern front-end 
web applications. Using Firebase Hosting, you can deploy SSL-enabled web apps 
to your own domain on a global content-delivery network (CDN) from a single command.
Advanced Usage

For advanced developers, Firebase has the capability to access multiple Apps at a 
time, each with their own configuration information. Usually, a program will only 
have a single (default) App. In that case, you can use a shorthand notation, such 
as firebase.database(), to access individual services of the default App.

When you need to access services across multiple Firebase Apps, you do so via 
methods of each individual Firebase App:

  // Intialize the "[DEFAULT]" App
  var mainApp = firebase.initializeApp({
    // ...
  });

  // Intialize a "Secondary" App
  var secondaryApp = firebase.initializeApp({
    // ...
  }, "Secondary");

  // Each app has its own configuration options and authentication state
  mainApp.database().ref("path/to/data").set(value);
  secondaryApp.database().ref("path/to/data").set(anotherValue);


// Get a reference to the database service
  var database = firebase.database();


  ///////////////////////////////////////////////////////////////////////////////////////////////
SAVING DATA

 Save Data on the Web

There are four methods for writing data to the Firebase Realtime Database:
Method 	Common uses

set() 	Write or replace data to a defined path, such as users/<user-id>/<username>.
push() 	Add to a list of data. Every time you call push(), Firebase generates a unique key that 
        can also be used as a unique identifier, such as user-posts/<user-id>/<unique-post-id>.
update() 	Update some of the keys for a defined path without replacing all of the data.
transaction() 	Update complex data that could be corrupted by concurrent updates.

Note: By default, read and write access to your database is restricted so 
only authenticated users can read or write data. To get started without setting up Authentication, 
you can configure your rules for public access. This does make your database open to anyone, 
even people not using your app, so be sure to restrict your database again 
when you set up authentication.
Write, update, or delete data at a reference
Basic write operations

For basic write operations, you can use set() to save data to a specified reference, 
replacing any existing data at that path. For example a social blogging application might 
add a user with set() as follows:

function writeUserData(userId, name, email, imageUrl) {
  firebase.database().ref('users/' + userId).set({
    username: name,
    email: email,
    profile_picture : imageUrl
  });
}

Using set() overwrites data at the specified location, including any child nodes.
Append to a list of data

Use the push() method to append data to a list in multiuser applications. 
The push() method generates a unique key every time a new child is added to the 
specified Firebase reference. By using these auto-generated keys for each new element 
in the list, several clients can add children to the same location at the same time 
without write conflicts. The unique key generated by push() is based on a timestamp, 
so list items are automatically ordered chronologically.

You can use the reference to the new data returned by the push() method to get the 
value of the child's auto-generated key or set data for the child. The .key property of 
a push() reference contains the auto-generated key.

You can use these auto-generated keys to simplify flattening your data structure. 
For more information, see the data fan-out example.
Update specific fields

To simultaneously write to specific children of a node without overwriting other child 
nodes, use the update() method.

When calling update(), you can update lower-level child values by specifying a path 
for the key. If data is stored in multiple locations to scale better, you can update 
all instances of that data using data fan-out.

For example, a social blogging app might create a post and simultaneously update 
it to the recent activity feed and the posting user's activity feed using code like this:

function writeNewPost(uid, username, picture, title, body) {
  // A post entry.
  var postData = {
    author: username,
    uid: uid,
    body: body,
    title: title,
    starCount: 0,
    authorPic: picture
  };

  // Get a key for a new Post.
  var newPostKey = firebase.database().ref().child('posts').push().key;

  // Write the new post's data simultaneously in the posts list and the user's post list.
  var updates = {};
  updates['/posts/' + newPostKey] = postData;
  updates['/user-posts/' + uid + '/' + newPostKey] = postData;

  return firebase.database().ref().update(updates);
}

This example uses push() to create a post in the node containing posts for 
all users at /posts/$postid and simultaneously retrieve the key. The key can then 
be used to create a second entry in the user's posts at /user-posts/$userid/$postid.

Using these paths, you can perform simultaneous updates to multiple locations in the JSON 
tree with a single call to update(), such as how this example creates the new post in both 
locations. Simultaneous updates made this way are atomic: either all updates succeed or all updates fail.
Delete data

The simplest way to delete data is to call remove() on a reference to the location of that data.

You can also delete by specifying null as the value for another write operation such as set() 
or update(). You can use this technique with update() to delete multiple children in a single API call.
Receive a Promise

To know when your data is committed to the Firebase Realtime Database server, you can use a 
Promise. Both set() and update() can return a Promise you can use to know when the write is 
committed to the database.
Save data as transactions

When working with data that could be corrupted by concurrent modifications, such as 
incremental counters, you can use a transaction operation. You can give this operation 
an update function and an optional completion callback. The update function takes the 
current state of the data as an argument and returns the new desired state you would 
like to write. If another client writes to the location before your new value is successfully 
written, your update function is called again with the new current value, and the write is retried.

For instance, in the example social blogging app, you could allow users to star and unstar 
posts and keep track of how many stars a post has received as follows:

function toggleStar(postRef, uid) {
  postRef.transaction(function(post) {
    if (post) {
      if (post.stars && post.stars[uid]) {
        post.starCount--;
        post.stars[uid] = null;
      } else {
        post.starCount++;
        if (!post.stars) {
          post.stars = {};
        }
        post.stars[uid] = true;
      }
    }
    return post;
  });
}

Using a transaction prevents star counts from being incorrect if multiple 
users star the same post at the same time or the client had stale data. 
If the transaction is rejected, the server returns the current value to the 
client, which runs the transaction again with the updated value. This repeats 
until the transaction is accepted or you abort the transaction.
Note: Because your update function is called multiple times, it must be able 
to handle null data. Even if there is existing data in your remote database, 
it may not be locally cached when the transaction function is run, resulting 
in null for the initial value.
Write data offline

If a client loses its network connection, your app will continue functioning correctly.

Every client connected to a Firebase database maintains its own internal version 
of any active data. When data is written, it's written to this local version first. 
The Firebase client then synchronizes that data with the remote database servers and 
with other clients on a "best-effort" basis.

As a result, all writes to the database trigger local events immediately, before any 
data is written to the server. This means your app remains responsive regardless of network 
latency or connectivity.

Once connectivity is reestablished, your app receives the appropriate set of events so that 
the client syncs with the current server state, without having to write any custom code.
Note: The Firebase Realtime Database web APIs do not persist data offline outside of the session. 
In order for writes to be persisted to the server, the web page must not be closed before the data 
is written to the server.


////////////////////////////////////////////////////////////////////////////////////////////////
PROPER DATA SAVING 
 Structure Your Database

This guide covers some of the key concepts in data architecture and best practices 
for structuring the JSON data in your Firebase Realtime Database.

Building a properly structured database requires quite a bit of forethought. 
Most importantly, you need to plan for how data is going to be saved and later 
retrieved to make that process as easy as possible.
How data is structured: it's a JSON tree

All Firebase Realtime Database data is stored as JSON objects. You can think of the 
database as a cloud-hosted JSON tree. Unlike a SQL database, there are no tables or records. 
When you add data to the JSON tree, it becomes a node in the existing JSON structure with 
an associated key. You can provide your own keys, such as user IDs or semantic names, or 
they can be provided for you using push().

If you create your own keys, they must be UTF-8 encoded, can be a maximum of 768 bytes, 
and cannot contain ., $, #, [, ], /, or ASCII control characters 0-31 or 127.

For example, consider a chat application that allows users to store a basic profile 
and contact list. A typical user profile is located at a path, such as /users/$uid. 
The user alovelace might have a database entry that looks something like this:

{
  "users": {
    "alovelace": {
      "name": "Ada Lovelace",
      "contacts": { "ghopper": true },
    },
    "ghopper": { ... },
    "eclarke": { ... }
  }
}

Although the database uses a JSON tree, data stored in the database can be 
represented as certain native types that correspond to available JSON types 
to help you write more maintainable code. For more information, see Save Data.
Best practices for data structure
Avoid nesting data

Because the Firebase Realtime Database allows nesting data up to 32 levels deep, 
you might be tempted to think that this should be the default structure. However, 
when you fetch data at a location in your database, you also retrieve all of its 
child nodes. In addition, when you grant someone read or write access at a node in 
your database, you also grant them access to all data under that node. Therefore, 
in practice, it's best to keep your data structure as flat as possible.

For an example of why nested data is bad, consider the following multiply-nested structure:

{
  // This is a poorly nested data architecture, because iterating the children
  // of the "chats" node to get a list of conversation titles requires
  // potentially downloading hundreds of megabytes of messages
  "chats": {
    "one": {
      "title": "Historical Tech Pioneers",
      "messages": {
        "m1": { "sender": "ghopper", "message": "Relay malfunction found. Cause: moth." },
        "m2": { ... },
        // a very long list of messages
      }
    },
    "two": { ... }
  }
}

With this nested design, iterating through the data becomes problematic. For example, 
listing the titles of chat conversations requires the entire chats tree, including all 
members and messages, to be downloaded to the client.
Flatten data structures

If the data is instead split into separate paths, also called denormalization, it can be 
efficiently downloaded in separate calls, as it is needed. Consider this flattened structure:

{
  // Chats contains only meta info about each conversation
  // stored under the chats's unique ID
  "chats": {
    "one": {
      "title": "Historical Tech Pioneers",
      "lastMessage": "ghopper: Relay malfunction found. Cause: moth.",
      "timestamp": 1459361875666
    },
    "two": { ... },
    "three": { ... }
  },

  // Conversation members are easily accessible
  // and stored by chat conversation ID
  "members": {
    // we'll talk about indices like this below
    "one": {
      "ghopper": true,
      "alovelace": true,
      "eclarke": true
    },
    "two": { ... },
    "three": { ... }
  },

  // Messages are separate from data we may want to iterate quickly
  // but still easily paginated and queried, and organized by chat
  // conversation ID
  "messages": {
    "one": {
      "m1": {
        "name": "eclarke",
        "message": "The relay seems to be malfunctioning.",
        "timestamp": 1459361875337
      },
      "m2": { ... },
      "m3": { ... }
    },
    "two": { ... },
    "three": { ... }
  }
}

It's now possible to iterate through the list of rooms by downloading only a few 
bytes per conversation, quickly fetching metadata for listing or displaying rooms in a UI. 
Messages can be fetched separately and displayed as they arrive, allowing the UI to stay 
responsive and fast.
Create data that scales

When building apps, it's often better to download a subset of a list. This is particularly 
common if the list contains thousands of records. When this relationship is static and one-directional, 
you can simply nest the child objects under the parent.

Sometimes, this relationship is more dynamic, or it may be necessary to denormalize this data. Many 
times you can denormalize the data by using a query to retrieve a subset of the data, as discussed 
in Retrieve Data.

But even this may be insufficient. Consider, for example, a two-way relationship between users and 
groups. Users can belong to a group, and groups comprise a list of users. When it comes time to 
decide which groups a user belongs to, things get complicated.

What's needed is an elegant way to list the groups a user belongs to and fetch only data for 
those groups. An index of groups can help a great deal here:

// An index to track Ada's memberships
{
  "users": {
    "alovelace": {
      "name": "Ada Lovelace",
      // Index Ada's groups in her profile
      "groups": {
         // the value here doesn't matter, just that the key exists
         "techpioneers": true,
         "womentechmakers": true
      }
    },
    ...
  },
  "groups": {
    "techpioneers": {
      "name": "Historical Tech Pioneers",
      "members": {
        "alovelace": true,
        "ghopper": true,
        "eclarke": true
      }
    },
    ...
  }
}

You might notice that this duplicates some data by storing the relationship under 
both Ada's record and under the group. Now alovelace is indexed under a group, and 
techpioneers is listed in Ada's profile. So to delete Ada from the group, it has 
to be updated in two places.

This is a necessary redundancy for two-way relationships. It allows you to quickly 
and efficiently fetch Ada's memberships, even when the list of users or groups scales 
into the millions or when Realtime Database security rules prevent access to some of the records.

This approach, inverting the data by listing the IDs as keys and setting the value to 
true, makes checking for a key as simple as reading /users/$uid/groups/$group_id and 
checking if it is null. The index is faster and a good deal more efficient than 
querying or scanning the data.
